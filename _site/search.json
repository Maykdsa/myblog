[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "myblog",
    "section": "",
    "text": "Atividade Cotação do Dólar\n\n\n\napi\n\ncode\n\npython\n\nDollar\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nMayk\n\n\n\n\n\n\n\n\n\n\n\n\nRegressão linear\n\n\n\nRegressão linear\n\ncode\n\npython\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nMayk\n\n\n\n\n\n\n\n\n\n\n\n\nAtividade API Onibus\n\n\n\nAPI\n\nCODE\n\nPYTHON\n\n\n\n\n\n\n\n\n\nNov 20, 2025\n\n\nMayk de Sá\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Atividade Cotação do Dólar",
    "section": "",
    "text": "Neste Post está a atividade sobre a cotação do Dollar.\n\n\nIntrodução\nEste blog apresenta a análise das cotações do dólar utilizando dados fornecidos pela API oficial do Banco Central (PTAX). O objetivo deste trabalho é demonstrar o uso de Python para realizar consultas em APIs, tratamento de dados, geração de gráficos e construção de um blog com Quarto.\nAo longo deste documento, cada célula de código será explicada detalhadamente.\n\n\n\nImports Necessários\nAntes de qualquer coisa, é preciso importar todas as bibliotecas utilizadas no projeto.\nimport calendar\nfrom datetime import datetime, timedelta\nimport pandas as pd\nimport plotly.express as px\nimport requests\n\n\n\nFunção para Obter Datas do Mês\nEsta função recebe um mês no formato MMYYYY e retorna o primeiro e o último dia daquele mês.\ndef datas(mes: str) -&gt; tuple[datetime, datetime]:\n    \"\"\"\n    Recebe o mês no formato MMYYYY e retorna a primeira e última data do mês.\n    \"\"\"\n    data_inicial = datetime.strptime(mes, \"%m%Y\")\n    ultimo_dia = calendar.monthrange(data_inicial.year, data_inicial.month)[1]\n    data_final = data_inicial.replace(day=ultimo_dia)\n    return data_inicial, data_final\n\n\n\nConstrução das Consultas para a API\nAs funções abaixo montam as URLs de consulta ao Banco Central.\ndef construir_query_periodo(data_inicial: datetime, data_final: datetime) -&gt; str:\n    return (\n        f\"?%40dataInicial='{data_inicial.strftime('%m%d%Y')}'\"\n        f\"&%40dataFinalCotacao='{data_final.strftime('%m%d%Y')}'\"\n        \"&%24format=json\"\n    )\n\n\ndef construir_query_dia(data: datetime) -&gt; str:\n    return f\"?%40dataCotacao='{data.strftime('%m%d%Y')}'&%24format=json\"\n\n\n\nConsulta dos Dados na API PTAX\nConsultamos tanto um período quanto um único dia, caso seja necessário.\nURL_PERIODO = (\n    \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n    \"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n)\n\nURL_DIA = (\n    \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n    \"CotacaoDolarDia(dataCotacao=@dataCotacao)\"\n)\n\n\ndef consultar_periodo(data_inicial: datetime, data_final: datetime) -&gt; list[dict]:\n    url = URL_PERIODO + construir_query_periodo(data_inicial, data_final)\n    resposta = requests.get(url).json()\n    return resposta[\"value\"]\n\n\ndef consultar_dia(data: datetime) -&gt; dict | None:\n    url = URL_DIA + construir_query_dia(data)\n    try:\n        resposta = requests.get(url).json()\n        return resposta[\"value\"][0]\n    except Exception:\n        return None\n\n\n\nProcessamento das Cotações\nAqui garantimos que todos os dias do mês tenham valores (preenchendo faltas com o valor do dia anterior).\ndef processar_cotacoes(cotacoes_uteis: list[dict], data_inicial: datetime, data_final: datetime) -&gt; list[float]:\n    cotacoes = [0.0 for _ in range(data_final.day)]\n\n    for cotacao in cotacoes_uteis:\n        dia = datetime.strptime(cotacao[\"dataHoraCotacao\"], \"%Y-%m-%d %H:%M:%S.%f\").day\n        cotacoes[dia - 1] = cotacao[\"cotacaoCompra\"]\n\n    for i in range(data_final.day):\n        if cotacoes[i] == 0.0:\n            if i == 0:\n                dia_fallback = data_inicial\n                cotacao_fallback = None\n\n                while cotacao_fallback is None:\n                    dia_fallback -= timedelta(days=1)\n                    cotacao_fallback = consultar_dia(dia_fallback)\n\n                cotacoes[i] = cotacao_fallback[\"cotacaoCompra\"]\n            else:\n                cotacoes[i] = cotacoes[i - 1]\n\n    return cotacoes\n\n\n\nConstrução do Gráfico\nUsamos Plotly para gerar um gráfico interativo das cotações.\ndef construir_grafico(mes: str, cotacoes, data_inicial: datetime, data_final: datetime):\n    valores = processar_cotacoes(cotacoes, data_inicial, data_final)\n\n    dias = list(range(1, len(valores) + 1))\n\n    df = pd.DataFrame({\"Dia\": dias, \"Cotação (R$)\": valores})\n\n    fig = px.line(\n        df,\n        x=\"Dia\",\n        y=\"Cotação (R$)\",\n        title=f\"Cotações do Dólar — {mes[:2]}/{mes[2:]}\"\n    )\n    fig.show()\n\n\n\nExecução Principal\ndef main():\nmes = \"052014\"  # Exemplo de mês escolhido\ndata_inicial, data_final = datas(mes)\ncotacoes = consultar_periodo(data_inicial, data_final)\nconstruir_grafico(mes, cotacoes, data_inicial, data_final)\nmain() ```\n\n\n\nConclusão\nEste trabalho demonstrou como utilizar Python para consultar APIs públicas, tratar dados com Pandas, gerar visualizações com Plotly e apresentar tudo em formato de blog utilizando Quarto. Essa abordagem é muito usada no mercado para análise de dados profissionais.\nCaso precise adicionar novos gráficos, indicadores, tabelas ou análises, posso complementar o blog conforme necessário."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Atividade API Onibus",
    "section": "",
    "text": "Introdução\nNeste post apresento uma aplicação em Python que consulta a API Olho Vivo da SPTrans para localizar linhas de ônibus, buscar suas paradas e capturar a posição atual dos veículos. O objetivo é demonstrar o uso de APIs reais, autenticação de tokens, manipulação de dados e geração de mapas interativos com Folium.\nToda a lógica apresentada aqui foi reescrita e reorganizada para fins acadêmicos, mantendo o funcionamento, porém com estrutura diferente do código original.\n\n\n\nImportações\nA aplicação utiliza três módulos principais: requests, folium e dotenv.\nimport os\nimport requests\nfrom folium import Map, Marker, Icon\nfrom dotenv import load_dotenv\nCarregando variáveis de ambiente:\nload_dotenv(\".env\")\n\n\n\nAutenticação na API\nA API da SPTrans requer autenticação via token. Aqui encapsulei o processo em uma função clara e direta.\ndef autenticar_sistema(sessao: requests.Session) -&gt; bool:\n    \"\"\"\n    Realiza autenticação com o token armazenado no arquivo .env.\n    \"\"\"\n    print(\"→ Autenticando no sistema da SPTrans...\")\n\n    token = os.getenv(\"SPTRANS_TOKEN\")\n    url = f\"http://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={token}\"\n\n    resp = sessao.post(url)\n\n    if resp.text.lower() == \"true\":\n        print(\"✔ Autenticação concluída.\")\n        return True\n\n    print(\"✖ Token inválido ou não encontrado.\")\n    return False\n\n\n\nFunções de Consulta\n\nBuscar linhas por termo\ndef obter_linhas(sessao: requests.Session, termo: str) -&gt; list[dict]:\n    print(f\"→ Buscando linhas contendo: {termo}\")\n    url = f\"http://api.olhovivo.sptrans.com.br/v2.1/Linha/Buscar?termosBusca={termo}\"\n    return sessao.get(url).json()\n\n\nBuscar paradas da linha\ndef obter_paradas(sessao: requests.Session, cod_linha: int) -&gt; list[dict]:\n    url = f\"http://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha?codigoLinha={cod_linha}\"\n    return sessao.get(url).json()\n\n\nBuscar posições dos ônibus\ndef obter_posicoes(sessao: requests.Session, cod_linha: int) -&gt; list[dict]:\n    url = f\"http://api.olhovivo.sptrans.com.br/v2.1/Posicao/Linha?codigoLinha={cod_linha}\"\n    dados = sessao.get(url).json()\n    return dados.get(\"vs\", [])\n\n\n\n\nConstrução do Mapa Interativo\nUsamos Folium para marcar paradas e veículos.\ndef gerar_mapa(paradas: list[dict], veiculos: list[dict]) -&gt; Map:\n    centro = [paradas[0][\"py\"], paradas[0][\"px\"]]\n    mapa = Map(location=centro, zoom_start=14)\n\n    # Marca as paradas\n    for p in paradas:\n        Marker(\n            location=[p[\"py\"], p[\"px\"]],\n            popup=p[\"np\"],\n            icon=Icon(color=\"blue\", icon=\"info-sign\")\n        ).add_to(mapa)\n\n    # Marca os veículos\n    for v in veiculos:\n        marker = Marker(\n            location=[v[\"py\"], v[\"px\"]],\n            popup=f\"Veículo: {v['p']}\"\n        )\n        marker.add_to(mapa)\n        Icon(color=\"red\", icon=\"bus\", prefix=\"fa\").add_to(marker)\n\n    return mapa\n\n\n\nExecução da Aplicação\nO código completo da busca e geração do mapa está abaixo.\ndef executar_sistema():\n    sessao = requests.Session()\n\n    if not autenticar_sistema(sessao):\n        return\n\n    termo_pesquisa = \"Santana\"  # termo exemplo\n    linhas = obter_linhas(sessao, termo_pesquisa)\n\n    print(f\"→ {len(linhas)} linhas encontradas para '{termo_pesquisa}'.\")\n    print(\"→ Selecionando primeira linha válida...\")\n\n    paradas, posicoes, linha_selecionada = None, None, None\n\n    for ln in linhas:\n        codigo = ln[\"cl\"]\n        paradas = obter_paradas(sessao, codigo)\n        posicoes = obter_posicoes(sessao, codigo)\n\n        if paradas and posicoes:\n            linha_selecionada = ln\n            break\n\n    if not linha_selecionada:\n        print(\"✖ Nenhuma linha válida encontrada.\")\n        return\n\n    print(f\"✔ Linha selecionada: {linha_selecionada['tp']} - {linha_selecionada['ts']}\")\n\n    mapa = gerar_mapa(paradas, posicoes)\n    mapa\n\n\nexecutar_sistema()\n\n\n\nConclusão\nCom este projeto foi possível:\n\nautenticar em uma API real;\nbuscar dados de transporte público;\nprocessar e filtrar resultados úteis;\nexibir paradas e veículos em um mapa interativo;\nintegrar tudo isso em um blog Quarto."
  },
  {
    "objectID": "posts/atividade3.py/index.html",
    "href": "posts/atividade3.py/index.html",
    "title": "Regressão linear",
    "section": "",
    "text": "Neste post tem atividade da regressão linear .\nNão conseguir executar corretamente igual as outras estava dando erro no CODESPACE\n\n================================\n\n\nInstalação das bibliotecas\n\n\n================================\nimport sys import subprocess\ndef install(package): subprocess.check_call([sys.executable, “-m”, “pip”, “install”, package])\n\n\nInstalando dependências necessárias\ninstall(“numpy”) install(“pandas”) install(“matplotlib”)\n\n\n================================\n\n\nImportações\n\n\n================================\nimport numpy as np import pandas as pd import matplotlib.pyplot as plt\n\n\n================================\n\n\nFunção de Regressão Linear (LS)\n\n\n================================\ndef regressao_linear(X, y): # Cálculo clássico: (XᵀX)^(-1) Xᵀy X = np.array(X) y = np.array(y) resultado = np.linalg.inv(X.T @ X) @ X.T @ y return resultado[0], resultado[1] # intercepto, inclinação\n\n\n================================\n\n\nLeitura dos dados\n\n\n================================\ndados_x = [] matriz_X = []\nwith open(“X.txt”) as f: for linha in f: valor = float(linha.strip()) dados_x.append(valor) matriz_X.append([1.0, valor])\ndados_y = [] with open(“y.txt”) as f: for linha in f: dados_y.append(float(linha.strip()))\n\n\n================================\n\n\nCálculo da regressão\n\n\n================================\nintercepto, inclinacao = regressao_linear(matriz_X, dados_y)\n\n\n================================\n\n\nDataFrame para análise\n\n\n================================\ndf = pd.DataFrame({“x”: dados_x, “y”: dados_y})\n\n\n================================\n\n\nGráfico\n\n\n================================\nplt.scatter(df[“x”], df[“y”]) plt.plot(df[“x”], intercepto + inclinacao * df[“x”]) plt.xlabel(“X”) plt.ylabel(“Y”) plt.title(“Regressão Linear”) plt.grid(True) plt.savefig(“grafico.png”) plt.show()\n\n\n================================\n\n\nConclusão\n\n\n================================\nprint(“====== RESULTADO FINAL ======”) print(f”Intercepto (a): {intercepto}“) print(f”Inclinação (b): {inclinacao}“) print(”gráfico foi salvo como ‘grafico.png’.”)"
  }
]